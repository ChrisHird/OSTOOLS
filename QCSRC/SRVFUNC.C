#include <H/SRVFUNC>                        // Server Functions Header

// Function convert_buffer()
// purpose: Convert buffer to and from ASCII
// @parms
//      input buffer
//      conversion buffer
//      in length
//      out length
//      buffer len
//      conversion table
// returns 1 on success

int convert_buffer(char *inBuf,
                   char *outBuf,
                   int inBufLen,
                   int outBufLen,
                   iconv_t table) {
int ret = 0;                                // return value
size_t insz;                                // input len
size_t outsz;                               // output size
char *out_ptr;                              // buffer ptr
char *in_ptr;                               // buffer ptr

insz = inBufLen;
outsz = outBufLen;
in_ptr = inBuf;
out_ptr = outBuf;
ret = (iconv(table,(char **)&(in_ptr),&insz,(char **)&(out_ptr),&outsz));
return 1;
}

// Function cmd_errhdl()
// purpose: Handle any errors generated by command processing,sets count to value
//          which relates to the error captured
// @parms
//      exception info struct ptr
// returns nothing

static void cmd_errhdl(_INTRPT_Hndlr_Parms_T *excp_info) {
int *count;                                 // error counter
char Msg_Type[10] = "*INFO     ";           // msg type
char QRpy_Q[20] = {' '};                    // reply queue
char Msg_Key[4] = {' '};                    // msg key
Rcv_Msg_t rtv_dta;                          // msg buffer for retrieval
Os_EC_t Error_Code = {0};                   // error code struct

Error_Code.EC.Bytes_Provided = _ERR_REC;
// set the count ptr to exception
count = (int *)(excp_info->Com_Area);
// retrieve the message for the program
QMHRCVPM(&rtv_dta,
         sizeof(rtv_dta),
         "RCVM0200",
         "*         ",
         0,
         "*ANY      ",
         (char *) (&(excp_info->Msg_Ref_Key)),
         0,
         "*SAME     ",
         &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   return;
   }
// library already in library list
if(memcmp(excp_info->Msg_Id,"CPF2103",7) == 0) {
   // not really a problem so let flow through with no error
   }
else if(memcmp(excp_info->Msg_Id,"CPF2110",7) == 0) {
   // library does not exist
   *count = 1;
   }
// handle the message
QMHCHGEM(&(excp_info->Target),
         0,
         (char *) (&(excp_info->Msg_Ref_Key)),
         "*HANDLE   ",
         "",
         0,
         &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   }
// send an information copy to the message queue
QMHSNDM(excp_info->Msg_Id,
        rtv_dta.msg_struct.Message_File_Name,
        rtv_dta.msg_data,
        rtv_dta.msg_struct.Length_Data_Returned,
        Msg_Type,
        _DFT_MSGQ,
        1,
        QRpy_Q,
        Msg_Key,
        &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   }
return;
}


// Function Handle_SO()
// purpose: handle a sign on request
// @parms
//      socket
//      Prf Handle
// returns 1 on success

int Handle_SO(int accept_sd,
              char *Usr_hdl,
              iconv_t a_e_ccsid,
              iconv_t e_a_ccsid) {
int rc = 0;                                 // return code
int len = 0;                                // counter
char recv_buf[_32K];                        // recv buffer
char msg_dta[1024];                         // message buffer
char Profile[10] = {' '};                   // Profile
char Pwd[128] = {' '};                      // password
char convBuf[132];                          // conversion buffer
Os_EC_t Error_Code = {0};                   // error struct

Error_Code.EC.Bytes_Provided = _ERR_REC;
// first we need to retieve the profile
sprintf(msg_dta,"Please enter your Profile name : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   return -1;
   }
// make sure not too long. Our test server sends a '0A' at the end of the input so
// it needs to be dropped. In a future implementation we should consider alternatives
rc = recv(accept_sd,recv_buf,_32K,0);
// copy to the Profile holder which is initialized with all blanks after conversion
convert_buffer(recv_buf,convBuf,rc,132,a_e_ccsid);
// strip off the 'A0' byte.
len = rc -1;
if(len > 10) {
   sprintf(msg_dta,"Profile too long Sign On aborted");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
memcpy(Profile,convBuf,len);
// now get the password
sprintf(msg_dta,"Please enter your Password : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
if(rc != len) {
   return -1;
   }
// recv the password and convert
rc = recv(accept_sd,recv_buf,_32K,0);
convert_buffer(recv_buf,convBuf,rc,132,a_e_ccsid);
// strip off the 'A0' byte.
len = rc -1;
if(len > 128) {
   sprintf(msg_dta,"Password too long");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
memcpy(Pwd,convBuf,len);
// now check the password against the profile, CCSID of 0 means use the job ccsid
QsyGetProfileHandle(Usr_hdl,
                    Profile,
                    Pwd,
                    rc,
                    0,
                    &Error_Code);
if(Error_Code.EC.Bytes_Available) {
   snd_error_msg(Error_Code);
   return -1;
   }
return 1;
}

// Function handle_CM()
// purpose: Handle a command request
// @parms
//      socket
//      conversion table a-e
//      conversion table e-a
// returns 1 on success

int handle_CM(int accept_sd,
              iconv_t a_e_ccsid,
              iconv_t e_a_ccsid) {
volatile int e_count = 0;                   // error flag
int rc = 0;                                 // return code
int len = 0;                                // counter
char recv_buf[_32K];                        // recv buffer
char msg_dta[1024];                         // message buffer
char Cmd[1024] = {'\0'};                    // Command string converted
char convBuf[1024];                         // conversion buffer


// first we need to retieve the command
sprintf(msg_dta,"Please enter a command : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   return -1;
   }
// get the comman string to process
rc = recv(accept_sd,recv_buf,_32K,0);
// copy to the Profile holder which is initialized with all blanks after conversion
// maximum command size must be less than 1023 based on conversion buffer size
if(rc > 1023) {
   sprintf(msg_dta,"Command string too long");
   convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// command len is OK so convert the buffer
convert_buffer(recv_buf,convBuf,rc,132,a_e_ccsid);
// strip off the 'A0' byte.
len = rc -1;
memcpy(Cmd,convBuf,len);
// set up the error handler
#pragma exception_handler(cmd_errhdl,e_count,0,_C2_ALL,_CTLA_HANDLE)
// first make sure its correctly formed
e_count = 0;
QCMDCHK(Cmd,len);
if(e_count > 0) {
   sprintf(msg_dta,"Command check failed");
   convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// issue the command
e_count = 0;
QCMDEXC(Cmd,len);
if(e_count > 0) {
   if(e_count == 1) {
      sprintf(msg_dta,"Command execution failed as library does not exist");
      }
   else {
      sprintf(msg_dta,"Command execution failed");
      }
   convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// remove the handler
#pragma disable_handler
return 1;
}
