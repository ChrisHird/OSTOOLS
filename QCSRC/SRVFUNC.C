//
// Copyright (c) 2018 Chris Hird
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// Disclaimer :
// This code is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#include <H/SRVFUNC>                        // Server Functions Header
#include <H/SPCFUNC>                        // user space functions

// Function convert_buffer()
// purpose: Convert buffer to and from ASCII
// @parms
//      input buffer
//      conversion buffer
//      in length
//      out length
//      buffer len
//      conversion table
// returns 1 on success

int convert_buffer(char *inBuf,
                   char *outBuf,
                   int inBufLen,
                   int outBufLen,
                   iconv_t table) {
int ret = 0;                                // return value
size_t insz;                                // input len
size_t outsz;                               // output size
char *out_ptr;                              // buffer ptr
char *in_ptr;                               // buffer ptr

insz = inBufLen;
outsz = outBufLen;
in_ptr = inBuf;
out_ptr = outBuf;
ret = (iconv(table,(char **)&(in_ptr),&insz,(char **)&(out_ptr),&outsz));
return 1;
}

// Function cmd_errhdl()
// purpose: Handle any errors generated by command processing,sets count to value
//          which relates to the error captured
// @parms
//      exception info struct ptr
// returns nothing

static void cmd_errhdl(_INTRPT_Hndlr_Parms_T *excp_info) {
int *count;                                 // error counter
char Msg_Type[10] = "*INFO     ";           // msg type
char QRpy_Q[20] = {' '};                    // reply queue
char Msg_Key[4] = {' '};                    // msg key
Rcv_Msg_t rtv_dta;                          // msg buffer for retrieval
Os_EC_t Error_Code = {0};                   // error code struct

Error_Code.EC.Bytes_Provided = _ERR_REC;
// set the count ptr to exception
count = (int *)(excp_info->Com_Area);
// retrieve the message for the program
QMHRCVPM(&rtv_dta,
         sizeof(rtv_dta),
         "RCVM0200",
         "*         ",
         0,
         "*ANY      ",
         (char *) (&(excp_info->Msg_Ref_Key)),
         0,
         "*SAME     ",
         &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   return;
   }
// library already in library list
if(memcmp(excp_info->Msg_Id,"CPF2103",7) == 0) {
   // not really a problem so let flow through with no error
   }
else if(memcmp(excp_info->Msg_Id,"CPF2110",7) == 0) {
   // library does not exist
   *count = 1;
   }
// handle the message
QMHCHGEM(&(excp_info->Target),
         0,
         (char *) (&(excp_info->Msg_Ref_Key)),
         "*HANDLE   ",
         "",
         0,
         &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   }
// send an information copy to the message queue
QMHSNDM(excp_info->Msg_Id,
        rtv_dta.msg_struct.Message_File_Name,
        rtv_dta.msg_data,
        rtv_dta.msg_struct.Length_Data_Returned,
        Msg_Type,
        _DFT_MSGQ,
        1,
        QRpy_Q,
        Msg_Key,
        &Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   }
return;
}


// Function Handle_SO()
// purpose: handle a sign on request
// @parms
//      socket
//      Prf Handle
// returns 1 on success

int Handle_SO(int accept_sd,
              char *Usr_hdl,
              iconv_t a_e_ccsid,
              iconv_t e_a_ccsid) {
int rc = 0;                                 // return code
int len = 0;                                // counter
char recv_buf[_32K];                        // recv buffer
char msg_dta[1024];                         // message buffer
char Profile[10] = {' '};                   // Profile
char Pwd[128] = {' '};                      // password
char convBuf[132];                          // conversion buffer
Os_EC_t Error_Code = {0};                   // error struct

Error_Code.EC.Bytes_Provided = _ERR_REC;
// first we need to retieve the profile
sprintf(msg_dta,"Please enter your Profile name : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   sprintf(msg_dta,"Failed to send request for Profile");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
// make sure not too long. Our test server sends a '0A' at the end of the input so
// it needs to be dropped. In a future implementation we should consider alternatives
rc = recv(accept_sd,recv_buf,_32K,0);
// copy to the Profile holder which is initialized with all blanks after conversion
convert_buffer(recv_buf,convBuf,rc,132,a_e_ccsid);
// strip off the 'A0' byte.
//len = rc -1;
if(rc > 10) {
   sprintf(msg_dta,"Profile too long Sign On aborted");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
memcpy(Profile,convBuf,rc);
// now get the password
sprintf(msg_dta,"Please enter your Password : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,132,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
if(rc != len) {
   sprintf(msg_dta,"Failed to send request for Password");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
// recv the password and convert
rc = recv(accept_sd,recv_buf,_32K,0);
convert_buffer(recv_buf,convBuf,rc,132,a_e_ccsid);
// strip off the 'A0' byte.
//len = rc -1;
if(rc > 128) {
   sprintf(msg_dta,"Password too long");
   snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   return -1;
   }
memcpy(Pwd,convBuf,rc);
// now check the password against the profile, CCSID of 0 means use the job ccsid
QsyGetProfileHandle(Usr_hdl,
                    Profile,
                    Pwd,
                    rc,
                    0,
                    &Error_Code);
if(Error_Code.EC.Bytes_Available) {
   snd_error_msg(Error_Code);
   return -1;
   }
return 1;
}

// Function handle_CM()
// purpose: Handle a command request
// @parms
//      socket
//      conversion table a-e
//      conversion table e-a
// returns 1 on success

int handle_CM(int accept_sd,
              iconv_t a_e_ccsid,
              iconv_t e_a_ccsid) {
volatile int e_count = 0;                   // error flag
int rc = 0;                                 // return code
int len = 0;                                // counter
char recv_buf[_32K];                        // recv buffer
char msg_dta[1024];                         // message buffer
char Cmd[1024] = {'\0'};                    // Command string converted
char convBuf[_1KB];                         // conversion buffer

// first we need to retieve the command
sprintf(msg_dta,"Please enter a command : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   return -1;
   }
// get the comman string to process
rc = recv(accept_sd,recv_buf,_32K,0);
// copy to the Profile holder which is initialized with all blanks after conversion
// maximum command size must be less than 1023 based on conversion buffer size
if(rc > 1023) {
   sprintf(msg_dta,"Command string too long");
   convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// command len is OK so convert the buffer
convert_buffer(recv_buf,convBuf,rc,_1KB,a_e_ccsid);
// strip off the 'A0' byte.
len = rc -1;
memcpy(Cmd,convBuf,len);
// set up the error handler
#pragma exception_handler(cmd_errhdl,e_count,0,_C2_ALL,_CTLA_HANDLE)
// first make sure its correctly formed
e_count = 0;
QCMDCHK(Cmd,len);
if(e_count > 0) {
   sprintf(msg_dta,"Command check failed");
   convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// issue the command
e_count = 0;
QCMDEXC(Cmd,len);
if(e_count > 0) {
   if(e_count == 1) {
      sprintf(msg_dta,"Command execution failed as library does not exist");
      }
   else {
      sprintf(msg_dta,"Command execution failed");
      }
   convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
   rc = send(accept_sd,convBuf,len,0);
   return -1;
   }
// remove the handler
#pragma disable_handler
return 1;
}

// Function handle_MR()
// purpose: retrieve messages from a message queue
// @parms
//      socket
//      conversion table a-e
//      conversion table e-a
// returns 1 on success

int handle_MR(int accept_sd,
              iconv_t a_e_ccsid,
              iconv_t e_a_ccsid) {
int rc = 0;                                 // return code
int len = 0;                                // counter
int Min_Recs = 50;                          // Async record request
int Num_Recs = 0;                           // number records processed
int Total_Recs = 0;                         // total records in queue
int i = 0;                                  // counter
int more = 1;                               // more messages
char Sort_Info = '0';                       // msg sort (not sorted)
char recv_buf[_32K];                        // recv buffer
char msg_dta[1024];                         // message buffer
char convBuf[_1KB];                         // conversion buffer
char Q_MsgQ[22];                            // qualified message queue
char SPC_Name[20] = "QGYOLMSG  QTEMP     "; // usrspc for data
char ListInfo[80];                          // list info returned by API
char QI[21] = {'1',' '};                    // msgq to list
char QL[44];                                // holder
char Msg_Buf[_1KB];                         // returned message
char MsgQ[20] = "          *LIBL     ";     // message queue
char json_str[500];                         // json string
char msgid[8];                              // message ID
char sev[3];                                // message severity
char msg[133];                              // message
char ts[21];                                // time stamp
char *space;                                // usrspc pointer
char *tmp;                                  // temp ptr
char *Data;                                 // data ptr
SelInf_t SI = {0};                          // selection info
Msg_Ret_t *QIPtr;                           // queue info ptr
time_fmt_t *t;                              // time struct ptr
date_fmt_t *d;                              // date struct ptr
Qgy_Olmsg_ListInfo_t *ret_info;             // returned hdr
Qgy_Olmsg_RecVar_t *ret_msg;                // returned message
Qgy_Olmsg_IDFieldInfo_t *field_data;        // returned msg dta
Os_EC_t Error_Code = {0};                   // Error Code

Error_Code.EC.Bytes_Provided = _ERR_REC;
// first get the message queue name
sprintf(msg_dta,"Please enter the message Queue Name : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   return -1;
   }
// get the message queue to process
rc = recv(accept_sd,recv_buf,_32K,0);
// convert to EBCDIC
convert_buffer(recv_buf,convBuf,rc,_1KB,a_e_ccsid);
// copy with removed A0
memcpy(MsgQ,convBuf,rc);
// set up the message queue to retrieve, '1' denotes message queue
memcpy(&QI[1],MsgQ,20);
// get a space pointer for the messages
if(Get_Spc_Ptr(SPC_Name,&space,_1MB) != 1) {
   return -1;
   }
memcpy(SI.osData.List_Direction,"*PRV      ",10);
// return all messages
SI.osData.Severity_Criteria = 0;
// max message length for 0302 key
SI.osData.Max_Msg_Length = 132;
// help length, we do not request
SI.osData.Max_Help_Length = 0;
//offset to selection criteria (44 bytes)
SI.osData.Sel_Criteria_Offset = sizeof(_Packed struct Qgy_Olmsg_MsgSelInfo);
// number of selections
SI.osData.Num_Sel_Criteria = 1;
// offset to keys
SI.osData.Start_Msg_Keys_Offset = 54;
SI.osData.Retd_Fields_IDs_Offset = 58;
SI.osData.Num_Fields = 2;
// select all with key based on last message added
memcpy(SI.Sel_Cri[0],"*ALL      ",10);
memset(SI.Msg_Key[0],0xFF,4);
// fields to return, msg with data and reply status
SI.FieldID[0] = 302;
SI.FieldID[1] = 1001;
// set up the pointer to the message structure
ret_msg = (Qgy_Olmsg_RecVar_t *)Msg_Buf;
// set up the pointer to list info
ret_info = (Qgy_Olmsg_ListInfo_t *)ListInfo;
// date and time conversion
t = (time_fmt_t *)ret_msg->Time_Sent;
d = (date_fmt_t *)ret_msg->Date_Sent;
do {
   // pull the messages into the user space
   QGYOLMSG(space,
            _1MB,
            ListInfo,
            Min_Recs,
            &Sort_Info,
            &SI,
            sizeof(SI),
            QI,
            QL,
            &Error_Code);
   if(Error_Code.EC.Bytes_Available > 0) {
      snd_error_msg(Error_Code);
      return -1;
      }
   sprintf(msg_dta,"Messages %d - %d",ret_info->Records_Retd,ret_info->Total_Records);
   Total_Recs += ret_info->Records_Retd;
   Num_Recs = ret_info->Records_Retd;
   //snd_msg("GEN0001",msg_dta,strlen(msg_dta));
   // if nothing to do just break
   if(ret_info->Records_Retd <= 0) {
      sprintf(msg_dta,"No records to read");
      snd_msg("GEN0001",msg_dta,strlen(msg_dta));
      break;
      }
   // loop through and get the messages to be sent
   for(i = 1; i <= Num_Recs; i++) {
      QGYGTLE(Msg_Buf,
              sizeof(Msg_Buf),
              ret_info->Request_Handle,
              &ListInfo,
              1,
              i,
              &Error_Code);
      if(Error_Code.EC.Bytes_Available > 0) {
         // clean up and return to caller
         if(memcmp(Error_Code.EC.Exception_Id,"GUI0006",7) != 0)
            snd_error_msg(Error_Code);
         QGYCLST(ret_info->Request_Handle,&Error_Code);
         return -1;
         }
      // set up the access to the data
      tmp = Msg_Buf;
      tmp += ret_msg->Offset_to_Fields_Retd;
      field_data = (Qgy_Olmsg_IDFieldInfo_t *)tmp;
      Data = tmp;
      Data += sizeof(_Packed struct Qgy_Olmsg_IDFieldInfo);
      sprintf(msgid,"%.7s",ret_msg->Msg_ID);
      sprintf(sev,"%.2d",ret_msg->Msg_Severity);
      memset(msg,'\0',133);
      memcpy(msg,Data,field_data->Data_Length);
      sprintf(ts,"20%.2s-%.2s-%.2s %.2s:%.2s:%.2s",d->Y,d->M,d->D,t->H,t->M,t->S);
      sprintf(json_str,"{msgid : %s,sev : %s,msg : %s,ts : %s}",msgid,sev,msg,ts);
      // convert to ASCII and send
      convert_buffer(json_str,convBuf,strlen(json_str),_1KB,e_a_ccsid);
      rc = send(accept_sd,convBuf,strlen(json_str),0);
      // get response
      rc = recv(accept_sd,recv_buf,1024,0);
      // if no response break
      if(rc <= 0) {
         break;
         }
      }
   // set the starting message key
   memcpy(SI.Msg_Key[0],ret_msg->Msg_Key,4);
   } while(Total_Recs < ret_info->Total_Records);
// clean up the resources
QGYCLST(ret_info->Request_Handle,&Error_Code);
if(Error_Code.EC.Bytes_Available > 0) {
   snd_error_msg(Error_Code);
   return -1;
   }
// first get the message queue name
sprintf(msg_dta,"End of Messages : ");
len = strlen(msg_dta);
convert_buffer(msg_dta,convBuf,len,_1KB,e_a_ccsid);
rc = send(accept_sd,convBuf,len,0);
// make sure the data was sent
if(rc != len) {
   return -1;
   }
return 1;
}

// function Crt_Q_Name()
// Purpose: To create a qualified object name. LIB/OBJ
// @parms
//      string object
//      string q name
// returns 1 success

int Crt_Q_Name(char *Object,
               char *Q_Name) {
int i,j = 0;                                // counters

for(i = 10,j = 0; i < 20; i++,j++) {
   Q_Name[j] = (Object[i] == ' ') ? '\0' : Object[i];
   }
Q_Name[j] = '\0';
strcat(Q_Name,"/");
j = strlen(Q_Name);
for(i = 0;i < 10;i++,j++) {
   Q_Name[j] = (Object[i] == ' ') ? '\0' : Object[i];
   }
Q_Name[j] = '\0';
return 1;
}

// function Cvt_Hex_Buf
// Convert Hex to Ascii for output
// @parms
//      char Ptr hex buffero
//      char ptr ascii buffer
//      int length hex buffer
// returns 1

int Cvt_Hex_Buf(char *inbuf,
                char *outbuf,
                int buflen) {
char *tmp;

tmp = inbuf;
while(buflen) {
   sprintf(outbuf,"%02x",*tmp);
   buflen--;
   tmp++;
   outbuf += 2;
   }
return buflen;
}
